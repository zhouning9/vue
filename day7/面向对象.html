<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>

    /*
        面向对象：它是一种 对象数据类型为导向的编程思想
        类                  实例
        Array               所有的数组 都是 Array 这个类的实例

        实例的 __proto__ 属性是指向类的prototype属性的

        // JS中的常见内置类 Array Object Number String Boolean ...

        [].__proto__=== Array.prototype
        Object.prototype === ({name:12}).__proto__


        我们把 Array.prototype 称为 数组类的原型对象
        每个数组的 __proto__ 都是指向 所属类的原型对象

        原型链：它是一种属性的查找机制,先在自身查找某属性,若没有则去所属类的原型上查找,
               再没有,向上级类的原型上查找,一直查到基类的原型上;

    */

    [].__proto__.push = function () {
        console.log('this is my push ')
    };
    Array.prototype.pop = function () {
        console.log('this is my pop');
    };
    let ary4 = [];
    ary4.push(1, 2, 3);
    ary4.pop();
    console.log(ary4);

    // 查看数据类型的另一种方式
    Object.prototype.toString.call([]);
    ({}).toString.call([]);

    // 自定义一个类
    function Person() {
        this.a = 12;
        this.b = 13;
    }
    Person.prototype.sum = function (a, b) {
        console.log(a + b);
        return this;
    }
    Person.prototype.sum2 = function (a, b) {
        console.log((a + b) * 10);
    }

    // 新创建一个该类的实例
    let per1 = new Person();
    let per2 = new Person();
    console.dir(per1, per2);
    console.log(per1 === per2);
    Person.prototype.constructor === Person;
    // 原型上的 constructor 属性是向函数本身的
    // console.log(per1, sum(1, 2));
    per1.sum(1, 2).sum2(2, 3);
    // 链式写法的关键在于前边的返回值,得是该类的实例
</script>